for(i in 1:length(unique(xMZ))){
for(j in 1:length(unique(yMZ))){
ss1[i,j] <- sum(xMZ > sortxuni[i] & yMZ > sortyuni[j])
}
}
for(i in 1:length(unique(xMZ))){
for(j in 1:length(unique(yMZ))){
ss1[i,j] <- sum(xMZ > sortxuni[i] & yMZ > sortyuni[j])
}
}
#ss1 <- dabrowska(xMZ, yMZ, xstatusMZ, ystatusMZ)
ss1 <- matrix(NA, nrow = length(unique(xMZ)), ncol = length(unique(yMZ)))
for(i in 1:length(unique(xMZ))){
for(j in 1:length(unique(yMZ))){
ss1[i,j] <- sum(xMZ > sortxuni[i] & yMZ > sortyuni[j])
}
}
for(i in 1:length(unique(xMZ))){
print(i)
for(j in 1:length(unique(yMZ))){
ss1[i,j] <- sum(xMZ >= sortxuni[i] & yMZ >= sortyuni[j])
}
}
errors <- ss1 * restaurant$res
cumres <- t(apply(apply(errors, 2, cumsum), 1, cumsum))
qplot(sort(unique(xMZ)), diag(cumres), geom = "line") + xlab("t") +
ylab("Cumulative Residuals")
test <- max(abs(cumres))
plot(sort(unique(xMZ)), diag(cumres), type = 'l', xlab = "t",
ylim = c(min(c(plots, diag(cumres))), max(c(plots, diag(cumres)))),
ylab = "Cumulative Residuals")
plot(sort(unique(xMZ)), diag(cumres), type = 'l', xlab = "t",
ylim = c(-40,40),
ylab = "Cumulative Residuals")
plots <- matrix(NA, nrow = length(unique(xMZ)), ncol = 20)
for(i in 1:20){
print(i)
samples <- sample(1:2500, replace = T)
testx <- xMZ[samples]
testy <- yMZ[samples]
testxstatus <- xstatusMZ[samples]
testystatus <- ystatusMZ[samples]
testres <- gammagliddenres(testx, testy, testxstatus, testystatus, chr)
testss <- dabrowska(testx, testy, testxstatusMZ, testystatus)
testerrors <- testss * testres$res
testcumres <- t(apply(apply(testerrors, 2, cumsum), 1, cumsum)) - cumres
if(length(unique(testx)) < length(unique(testy))){
lines(sort(unique(testx)), diag(testcumres))
}
else{
lines(sort(unique(testy)), diag(testcumres))
}
#plots[,i] <- diag(testcumres)
#tests[i] <- max(abs(testcumres))
}
n0 <- 2000
MZ1 <- MZf[1:n0,]
MZ1$birthYear <- MZ1$birthYear - mean(MZ1$birthYear)
### Transformation ###
model <- emfrail(Surv(time, status) ~ birthYear + cluster(tvparnr), data = MZ1)
beta <- as.numeric(model$coefficients)
birthYear <- MZ1$birthYear
time <- MZ1$time
status <- MZ1$status
timeuni <- sort(unique(time[status == 1]))
A <- matrix(0, nrow = length(timeuni), ncol = 2)
A[,1] <- timeuni
A[,2] <- cumsum(model$hazard)
newtimes <- numeric(n0)
for(i in 1:n0){
newtimes[i] <- 1 - exp(-max(c(1e-15, A[,2][A[,1] <= time[i]])) *
exp(beta * birthYear[i]))
}
model0 <- emfrail(Surv(time, status) ~ cluster(tvparnr),
data = data.frame(time = newtimes, status = status,
tvparnr = MZ1$tvparnr))
chr <- 1 + 1 / exp(model0$logtheta)
#MZ#
xMZ <- newtimes[MZ1$tv == 1]
yMZ <- newtimes[MZ1$tv == 2]
xstatusMZ <- MZ1$status[MZ1$tv == 1]
ystatusMZ <- MZ1$status[MZ1$tv == 2]
restaurant <- gammagliddenres(xMZ, yMZ, xstatusMZ, ystatusMZ, chr)
#ss1 <- dabrowska(xMZ, yMZ, xstatusMZ, ystatusMZ)
ss1 <- matrix(NA, nrow = length(unique(xMZ)), ncol = length(unique(yMZ)))
sortxuni <- sort(unique(xMZ))
sortyuni <- sort(unique(yMZ))
for(i in 1:length(unique(xMZ))){
print(i)
for(j in 1:length(unique(yMZ))){
ss1[i,j] <- sum(xMZ >= sortxuni[i] & yMZ >= sortyuni[j])
}
}
errors <- ss1 * restaurant$res
cumres <- t(apply(apply(errors, 2, cumsum), 1, cumsum))
qplot(sort(unique(xMZ)), diag(cumres), geom = "line") + xlab("t") +
ylab("Cumulative Residuals")
test
test <- max(abs(cumres))
test
plot(sort(unique(xMZ)), diag(cumres), type = 'l', xlab = "t",
ylim = c(min(c(plots, diag(cumres))), max(c(plots, diag(cumres)))),
ylab = "Cumulative Residuals")
plot(sort(unique(xMZ)), diag(cumres), type = 'l', xlab = "t",
ylim = c(-20, 20),
ylab = "Cumulative Residuals")
for(i in 1:20){
print(i)
samples <- sample(1:(n0/2), replace = T)
testx <- xMZ[samples]
testy <- yMZ[samples]
testxstatus <- xstatusMZ[samples]
testystatus <- ystatusMZ[samples]
testres <- gammagliddenres(testx, testy, testxstatus, testystatus, chr)
testss <- dabrowska(testx, testy, testxstatusMZ, testystatus)
testerrors <- testss * testres$res
testcumres <- t(apply(apply(testerrors, 2, cumsum), 1, cumsum)) - cumres
if(length(unique(testx)) < length(unique(testy))){
lines(sort(unique(testx)), diag(testcumres))
}
else{
lines(sort(unique(testy)), diag(testcumres))
}
#plots[,i] <- diag(testcumres)
#tests[i] <- max(abs(testcumres))
}
for(i in 1:20){
print(i)
samples <- sample(1:(n0/2), replace = T)
testx <- xMZ[samples]
testy <- yMZ[samples]
testxstatus <- xstatusMZ[samples]
testystatus <- ystatusMZ[samples]
testres <- gammagliddenres(testx, testy, testxstatus, testystatus, chr)
testss <- dabrowska(testx, testy, testxstatus, testystatus)
testerrors <- testss * testres$res
testcumres <- t(apply(apply(testerrors, 2, cumsum), 1, cumsum)) - cumres
if(length(unique(testx)) < length(unique(testy))){
lines(sort(unique(testx)), diag(testcumres), col = "gray")
}
else{
lines(sort(unique(testy)), diag(testcumres), col = "gray")
}
#plots[,i] <- diag(testcumres)
#tests[i] <- max(abs(testcumres))
}
tauPar
tauPar <- function(par = 0, dist = "gamma", output = "tau", type = "alpha"){
if(dist == "gamma"){
if(output == "tau"){
return(par / (2 + par))
}
else if(output == "par"){
return(2*par / (1-par))
}
else{
stop("output has to be either 'tau' or 'par'")
}
}
else if(dist == "posstab"){
if(type == "alpha"){
return(1 - par)
}
else if(type == "theta"){
if(output == "tau"){
return(1 - 1 / par)
}
else if(output == "par"){
return(1 / (1-tau))
}
else{
stop("type has to be either 'alpha' or 'theta'")
}
}
else{
stop("output has to be either 'tau' or 'par'")
}
}
else if(dist == "invgauss"){
laplace <- function(alpha){
L <- function(s) exp(alpha - sqrt(alpha) * sqrt(2*s + alpha))
LL <- function(s){
exp(alpha) * (-sqrt(alpha)) * (exp(-sqrt(alpha)*sqrt(2*s+alpha))*(-sqrt(alpha)) / (2*s+alpha) -
exp(-sqrt(alpha)*sqrt(2*s+alpha))*(2*s+alpha)^(-3/2))
}
f <- function(s) s*L(s)*LL(s)
4 * integrate(f, 0, Inf)$value - 1
}
if(output == "tau"){
if(type == "alpha"){
return(laplace(par))
}
else if(type == "theta"){
return(laplace(1/par))
}
else{
stop("type has to be either 'alpha' or 'theta'")
}
}
else if(output == "par"){
if(type == "alpha"){
return(uniroot(function(alpha) laplace(alpha) - par, interval = c(.0001, 100))$root)
}
else if(type == "theta"){
return(1 / uniroot(function(alpha) laplace(alpha) - par, interval = c(.0001, 100))$root)
}
else{
stop("type has to be either 'alpha' or 'theta'")
}
}
else{
stop("output has to be either 'tau' or 'par'")
}
}
else{"dist has to be either 'gamma', 'posstab' or 'invgauss'"}
}
library(microbenchmark)
tmp <- microbenchmark(tauPar(2))
tmp
tmp <- microbenchmark(tauPar(.5, output = "par", type = "theta", dist = "posstab"))
tmp <- microbenchmark(tauPar(.5, output = "par", type = "theta", dist = "posstab"))
tauPar <- function(par = 0, dist = "gamma", output = "tau", type = "alpha"){
if(dist == "gamma"){
if(output == "tau"){
return(par / (2 + par))
}
else if(output == "par"){
return(2*par / (1-par))
}
else{
stop("output has to be either 'tau' or 'par'")
}
}
else if(dist == "posstab"){
if(type == "alpha"){
return(1 - par)
}
else if(type == "theta"){
if(output == "tau"){
return(1 - 1 / par)
}
else if(output == "par"){
return(1 / (1-par))
}
else{
stop("type has to be either 'alpha' or 'theta'")
}
}
else{
stop("output has to be either 'tau' or 'par'")
}
}
else if(dist == "invgauss"){
laplace <- function(alpha){
L <- function(s) exp(alpha - sqrt(alpha) * sqrt(2*s + alpha))
LL <- function(s){
exp(alpha) * (-sqrt(alpha)) * (exp(-sqrt(alpha)*sqrt(2*s+alpha))*(-sqrt(alpha)) / (2*s+alpha) -
exp(-sqrt(alpha)*sqrt(2*s+alpha))*(2*s+alpha)^(-3/2))
}
f <- function(s) s*L(s)*LL(s)
4 * integrate(f, 0, Inf)$value - 1
}
if(output == "tau"){
if(type == "alpha"){
return(laplace(par))
}
else if(type == "theta"){
return(laplace(1/par))
}
else{
stop("type has to be either 'alpha' or 'theta'")
}
}
else if(output == "par"){
if(type == "alpha"){
return(uniroot(function(alpha) laplace(alpha) - par, interval = c(.0001, 100))$root)
}
else if(type == "theta"){
return(1 / uniroot(function(alpha) laplace(alpha) - par, interval = c(.0001, 100))$root)
}
else{
stop("type has to be either 'alpha' or 'theta'")
}
}
else{
stop("output has to be either 'tau' or 'par'")
}
}
else{"dist has to be either 'gamma', 'posstab' or 'invgauss'"}
}
tmp <- microbenchmark(tauPar(.5, output = "par", type = "theta", dist = "posstab"))
tmp
?mantelhaen.test
1.2/3.2
library(Rcpp)
sourceCpp('eyy.cpp')
setwd("~/Dropbox/RPackage/biSurv/src")
sourceCpp('eyy.cpp')
library(timereg)
data(diabetes)
x <- diabetes$time[diabetes$treat == 1]
y <- diabetes$time[diabetes$treat == 2]
y <- diabetes$time[diabetes$treat == 0]
xstatus <- diabetes$status[diabetes$treat == 1]
ystatus <- diabetes$status[diabetes$treat == 0]
xuni <- sort(unique(x))
yuni <- sort(unique(y))
eyy <- eyyfunc(x,y,xuni,yuni)
tmp <- microbenchmark(eyyfunc(x,y,xuni,yuni))
tmp
eyy[1:5,1:5]
tmp$time
125.5415 /(197^2) * 5000^2 / 1000
?NULL
tauCens
tauPar
tauCens <- function(x,y,xstatus,ystatus, alpha = .05){
KMx <- prodlim(Hist(x, xstatus) ~ 1)
KMy <- prodlim(Hist(y, ystatus) ~ 1)
tauu <- taucpp(x,y,xstatus,ystatus,KMx$surv,KMy$surv,KMx$time,KMy$time)
n <- length(x)
a <- tauu$a
b <- tauu$b
var.hat <- 4 * (sum(apply(a, 2, sum)^2) - sum(a^2)) *
(sum(apply(b, 2, sum)^2) - sum(b^2)) / (n * (n - 1) * (n - 2)) +
2 * sum(a^2) * sum(b^2) / (n * (n - 1))
var.hat <- var.hat / (sum(a^2) * sum(b^2))
data.frame(est = tauu$tau, SE = sqrt(var.hat),
lwr = tauu$tau-qnorm(1-alpha/2)*sqrt(var.hat),
upr = tauu$tau+qnorm(1-alpha/2)*sqrt(var.hat))
}
tauCens
tailDependence <- function(x, y, xstatus, ystatus, q, CI = FALSE, tail = "lwr", method = "dabrowska"){
if(method == "fast"){
KMy <- prodlim(Hist(y, ystatus) ~ 1)
FF <- 1-KMy$surv
qq <- min(KMy$time[FF >= q])
if(tail == "lwr"){
xx <- x[y < qq & ystatus == 1]
xxstatus <- xstatus[y < qq & ystatus == 1]
}
else if(tail == "upr"){
xx <- x[y > qq]
xxstatus <- xstatus[y > qq]
}
else{
stop("tail has to be either 'lwr' or 'upr'")
}
KMx <- prodlim(Hist(xx, xxstatus) ~ 1)
Fx <- 1-KMx$surv
if(tail == "upr"){
max(KMx$surv[KMx$time > qq])
}
else if(tail == "lwr"){
max(Fx[KMx$time < qq])
}
}
else if(method == "dabrowska"){
KMx <- prodlim(Hist(x,xstatus) ~ 1)
KMy <- prodlim(Hist(y,ystatus) ~ 1)
Fx <- 1 - KMx$surv
Fy <- 1 - KMy$surv
if(tail == "lwr"){
qx <- min(KMx$time[Fx >= q])
qy <- min(KMy$time[Fy >= q])
prob <- KMx$surv[KMx$time == qx] * KMy$surv[KMy$time == qy] *
prod(1 - H[xuni <= qx, yuni <= qy])
(1 - KMx$surv[KMx$time == qx] - KMy$surv[KMy$time == qy] + prob) / q
}
else if(tail == "upr"){
qx <- min(KMx$time[Fx >= q])
qy <- min(KMy$time[Fy >= q])
(KMx$surv[KMx$time == qx] * KMy$surv[KMy$time == qy] * prod(1 - H[xuni <= qx, yuni <= qy])) / (1 - q)
}
else{
stop("tail has to be either 'lwr' or 'upr'")
}
}
}
head(x)
tailDependence(x,y,xstatus,ystatus,.1)
library(prodlim)
tailDependence(x,y,xstatus,ystatus,.1)
tailDependence <- function(x, y, xstatus, ystatus, q, CI = FALSE, tail = "lwr", method = "dabrowska"){
if(method == "fast"){
KMy <- prodlim(Hist(y, ystatus) ~ 1)
FF <- 1-KMy$surv
qq <- min(KMy$time[FF >= q])
if(tail == "lwr"){
xx <- x[y < qq & ystatus == 1]
xxstatus <- xstatus[y < qq & ystatus == 1]
}
else if(tail == "upr"){
xx <- x[y > qq]
xxstatus <- xstatus[y > qq]
}
else{
stop("tail has to be either 'lwr' or 'upr'")
}
KMx <- prodlim(Hist(xx, xxstatus) ~ 1)
Fx <- 1-KMx$surv
if(tail == "upr"){
max(KMx$surv[KMx$time > qq])
}
else if(tail == "lwr"){
max(Fx[KMx$time < qq])
}
}
else if(method == "dabrowska"){
hazard0 <- hazards(x,y,xstatus,ystatus)
H <- (hazards0$lambda10 * hazards0$lambda01 - hazards0$lambda11) / ((1 - hazards0$lambda10) * (1 - hazards0$lambda01))
H[is.nan(H)] <- 0
KMx <- prodlim(Hist(x,xstatus) ~ 1)
KMy <- prodlim(Hist(y,ystatus) ~ 1)
Fx <- 1 - KMx$surv
Fy <- 1 - KMy$surv
if(tail == "lwr"){
qx <- min(KMx$time[Fx >= q])
qy <- min(KMy$time[Fy >= q])
prob <- KMx$surv[KMx$time == qx] * KMy$surv[KMy$time == qy] *
prod(1 - H[xuni <= qx, yuni <= qy])
(1 - KMx$surv[KMx$time == qx] - KMy$surv[KMy$time == qy] + prob) / q
}
else if(tail == "upr"){
qx <- min(KMx$time[Fx >= q])
qy <- min(KMy$time[Fy >= q])
(KMx$surv[KMx$time == qx] * KMy$surv[KMy$time == qy] * prod(1 - H[xuni <= qx, yuni <= qy])) / (1 - q)
}
else{
stop("tail has to be either 'lwr' or 'upr'")
}
}
}
tailDependence(x,y,xstatus,ystatus,.1)
hazards <- function(x,y,xstatus,ystatus){
xuni <- sort_unique(x)
yuni <- sort_unique(y)
hazardscpp(x,y,xstatus,ystatus,xuni,yuni)
}
tailDependence(x,y,xstatus,ystatus,.1)
hazards <- function(x,y,xstatus,ystatus){
xuni <- sort_unique(x)
yuni <- sort_unique(y)
hazardscpp(x,y,xstatus,ystatus,xuni,yuni)
}
hazards <- function(x,y,xstatus,ystatus){
xuni <- sort(unique(x))
yuni <- sort(unique(y))
hazardscpp(x,y,xstatus,ystatus,xuni,yuni)
}
tailDependence(x,y,xstatus,ystatus,.1)
getwd()
sourceCpp('bivariateHazardscpp.cpp')
tailDependence(x,y,xstatus,ystatus,.1)
h <- hazards(x,y,xstatus,ystatus)
rm(h)
tailDependence <- function(x, y, xstatus, ystatus, q, CI = FALSE, tail = "lwr", method = "dabrowska"){
if(method == "dabrowska"){
hazards0 <- hazards(x,y,xstatus,ystatus)
H <- (hazards0$lambda10 * hazards0$lambda01 - hazards0$lambda11) / ((1 - hazards0$lambda10) * (1 - hazards0$lambda01))
H[is.nan(H)] <- 0
KMx <- prodlim(Hist(x,xstatus) ~ 1)
KMy <- prodlim(Hist(y,ystatus) ~ 1)
Fx <- 1 - KMx$surv
Fy <- 1 - KMy$surv
if(tail == "lwr"){
qx <- min(KMx$time[Fx >= q])
qy <- min(KMy$time[Fy >= q])
prob <- KMx$surv[KMx$time == qx] * KMy$surv[KMy$time == qy] *
prod(1 - H[xuni <= qx, yuni <= qy])
(1 - KMx$surv[KMx$time == qx] - KMy$surv[KMy$time == qy] + prob) / q
}
else if(tail == "upr"){
qx <- min(KMx$time[Fx >= q])
qy <- min(KMy$time[Fy >= q])
(KMx$surv[KMx$time == qx] * KMy$surv[KMy$time == qy] * prod(1 - H[xuni <= qx, yuni <= qy])) / (1 - q)
}
else{
stop("tail has to be either 'lwr' or 'upr'")
}
}
else if(method == "fast"){
KMy <- prodlim(Hist(y, ystatus) ~ 1)
FF <- 1-KMy$surv
qq <- min(KMy$time[FF >= q])
if(tail == "lwr"){
xx <- x[y < qq & ystatus == 1]
xxstatus <- xstatus[y < qq & ystatus == 1]
}
else if(tail == "upr"){
xx <- x[y > qq]
xxstatus <- xstatus[y > qq]
}
else{
stop("tail has to be either 'lwr' or 'upr'")
}
KMx <- prodlim(Hist(xx, xxstatus) ~ 1)
Fx <- 1-KMx$surv
if(tail == "lwr"){
max(Fx[KMx$time < qq])
}
else if(tail == "upr"){
max(KMx$surv[KMx$time > qq])
}
}
}
tailDependence(x,y,xstatus,ystatus,.1)
tailDependence(x,y,xstatus,ystatus,.1, method = "fast")
tmp <- microbenchmark(tailDependence(x,y,xstatus,ystatus,.1), tailDependence(x,y,xstatus,ystatus,.1, method = "fast"))
tmp
tailDependence(x,y,xstatus,ystatus,.2)
tailDependence(x,y,xstatus,ystatus,.2, method = "fast")
